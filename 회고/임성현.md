# 주간 회고

<details>
	<summary>1주차: 230419 ~ 230430</summary>

### 📖Learned
1. 클린 코드
	 -> 클린 코드에 무지했었고, 그래서 하나의 메서드가 하나가 아닌 여러 기능(책임)을 처리하게
	 되었습니다. 이를 민수님께서 피드백을 주셨고, 각각의 기능마다 하나의 메서드로 분리하여
	 하나의 메서드가 하나의 기능(책임)을 가지도록 리팩토링 했습니다.


2. Mockito 라이브러리 사용
			-> 제대로 된 프로젝트의 경험이 전무하였기에, 테스트 코드 또한 강의에서 배운 방식밖에 몰랐습니다.
			그래서 이름만 알고 있던 Mockito 라이브러리를 처음 접했고, 사용법에 미숙했기에 팀원분의 코드나
			다른 분들의 테스트 코드를 참고하거나 여러 글들을 참고하여 얕게나마 사용할 수 있게 되었습니다.


3. 2개 이상의 @OneToMany 자식을 가지는 엔티티인 경우 예외 발생
	 -> 모집 게시판의 경우 2개 이상의 @OneToMnay 자식을 가지고 있습니다. 그래서 모집 게시판을 조회할
	 때 각각의 자식들까지 쿼리가 발생하게 되어서 이를 해결하기 위해 fetch join으로 시도를 했습니다.
	 하지만 예외가 발생하였고, 찾아본 결과 2개 이상의 @OneToMany 자식을 대상으로 fetch join을 사용
	 할 시에 예외가 발생한다고 합니다.
	 그래서 default_batch_fetch_size 속성을 통해 해당 문제를 해결했습니다.

</details>
<br />
<details>
	<summary>2주차: 230501 ~ 230507</summary>

### 📖Learned
- 값의 여부를 확인하기 위해 쿼리를 고민하던 중 COUNT쿼리와 Exists쿼리의 성능 차이가 존재함
을 알았으며, 프로젝트에서 Exists방식으로 쿼리를 구현하려고 하였지만 JPQL에서는 SELECT
EXISTS쿼리가 불가능하며, 값(데이터)의 여부를 판단하기 위해서는 COUNT쿼리를 사용해야
한다고 한다.

- Spring Data JPA에서는 메서드 명으로 ExsistsBy를 통해 값의 여부를 판단할 수 있다고 하지만
실제 쿼리를 보면 Exists가 아닌 limit 1 쿼리를 내부적으로 사용하여 최적화 한다고 한다.
그런데 이 둘의 성능 차이는 거의 동등하다고 한다. 역시 "백문이 불여일타"라고, 프로젝트로
JPA를 사용하면서, 강의로 보고 공부한 내용이랑 직접 사용해보면서 공부하는 거랑은 많은
차이가 존재함을 느꼈다.

### 😊Liked
- 혼자 개발 공부를 했을 때에는 나아가는 방향이 잘못된 방향임에도 불구하고 이를 알지 못하였
	지만 협업을 하며, 코드리뷰를 통해 나의 잘못된 방향이나 부족한 부분을 잡아주신 덕분에
	개발자로써의 좋은 역량을 쌓아가는 것 같다.

### 😓Lacked
- 배포를 해본 경험이 없고, 리눅스나 EC2를 제대로 사용해본 적이 없어 관련 명령어를 잘 알지
	못했다.
- SQL 쿼리에 대한 기본적인 지식이 많이 부족하다 보니, 이를 JPQL 방식의 쿼리를 작성하는 부분에서 섣불리 작성하지 못하는 것 같다.

### 🚀Longed for
- 따로 시간을 잡아 간단하게 나마 배포 연습을 해봐야 겠으며, 쿼리 부분의 기본기를 다시 공부
	해야 겠다.

</details>